<?php
/**
 *	Compiler.php | Dec 11, 2013
 *
 * @filesource
 * @license MIT
 * @copyright Copyright (c) 2013-2018, mAsT3RpEE's Zone
 *
 * This source file is subject to the MIT license that is bundled
 * with this source code in the file LICENSE.
 */

/**
 *
 * @package BLW\Core
 * @version GIT 0.2.0
 * @author Walter Otsyula <wotsyula@mast3rpee.tk>
 */
namespace BLW\Model;

use ArrayObject;
use Phar;
use CSSmin;
use JSMin;
use FilesystemIterator;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;

use BLW\Type\IFile;

use BLW\Model\Event\Generic as Event;
use BLW\Type\AMediatableObject;
use BLW\Type\IMediator;


// @codeCoverageIgnoreStart
if (! defined('BLW')) {

    if (strstr($_SERVER['PHP_SELF'], basename(__FILE__))) {
        header("$_SERVER[SERVER_PROTOCOL] 404 Not Found");
        header('Status: 404 Not Found');

        $_SERVER['REDIRECT_STATUS'] = 404;

        echo "<html>\r\n<head><title>404 Not Found</title></head><body bgcolor=\"white\">\r\n<center><h1>404 Not Found</h1></center>\r\n<hr>\r\n<center>nginx/1.5.9</center>\r\n</body>\r\n</html>\r\n";
        exit();
    }

    return false;
}
// @codeCoverageIgnoreEnd


/**
 * Compiler for BLW Library and BLW applications.
 *
 * @package BLW\Core
 * @api BLW
 * @version GIT 0.2.0
 * @since 1.0.0
 * @author mAsT3RpEE <wotsyula@mast3rpee.tk>
 */
class Compiler extends \BLW\Type\AMediatableObject
{
    /**
     * Directory to place compiled files.
     *
     * @var \BLW\Type\IFile $_Build
     */
    protected $_Build = NULL;

    /**
     * Base directory for compiler.
     *
     * @var \BLW\Type\IFile $_Root
     */
    protected $_Root = NULL;

    /**
     * Temporary storage directory.
     *
     * @var \BLW\Type\IFile $_Temp
     */
    protected $_Temp = NULL;

    /**
     * Contains all files needed in compilation.
     *
     * @var array $_Files
     */
    protected $_Files = array();

    /**
     * Constructor
     *
     * @throws \BLW\Model\InvalidArgumentException
     *            If:
	 *
     * <ul>
     * <li><code>$BuildPath</code> Is not a writable directory.</li>
     * <li><code>$RootPath</code> Is not a readable directory.</li>
     * <li><code>$TempPath</code> Is not a writable directory.</li>
     * </ul>
     *
     * @param \BLW\Type\IFile $BuildPath
     *            Directory to store compiled resouces.
     * @param \BLW\Type\IFile $RootPath
     *            [optional] Base path of compiler. <code>NULL</code> for current directory.
     * @param \BLW\Type\IFile $TempPath
     *            [optional] Directory to store temporary files. <code>NULL</code> for sys_get_temp_dir().
     * @param \BLW\Type\IMediator $Mediator
     *            [optional] Mediator for compiler.
     */
    public function __construct(IFile $BuildPath, IFile $RootPath = null, IFile $TempPath = null, IMediator $Mediator = null)
    {
        // Check arguments

        // Is $BuildPath a writable?
        if (! $BuildPath->isWritable()) {
            throw new InvalidArgumentException(0, '%header% $BuildPath is not writable');
            return null;
        }

        /// Is $BuildPath a directory
        elseif (! $BuildPath->isDir()) {
            throw new InvalidArgumentException(0, '%header% $BuildPath is not a directory');
            return null;
        }

        // Is $RootPath null?
        if (! $RootPath) {
            $RootPath = new GenericFile(getcwd());
        }

        // Is $RootPath a readable?
        elseif (! $BuildPath->isReadable()) {
            throw new InvalidArgumentException(1, '%header% $RootPath is not writable');
            return null;
        }

        /// Is $RootPath a directory
        elseif (! $RootPath->isDir()) {
            throw new InvalidArgumentException(1, '%header% $RootPath is not a directory');
            return null;
        }

        // Is $TempPath null?
        if (! $TempPath) {
            $TempPath = new GenericFile(sys_get_temp_dir());
        }

        // Is $TempPath writable
        elseif (! $TempPath->isWritable()) {
            throw new InvalidArgumentException(2, '%header% $TempPath is not writable');
            return null;
        }

        // Is $TempPath a directory
        elseif (! $TempPath->isDir()) {
            throw new InvalidArgumentException(2, '%header% $TempPath is not a directory');
            return null;
        }

        // Properties
        $this->_DataMapper = new ArrayObject();
        $this->_ID         = 'Compiler';
        $this->_Temp       = $TempPath;
        $this->_Build      = $BuildPath;
        $this->_Root       = $RootPath;
        $this->_Files      = array();

        // Mediator
        if ($Mediator) $this->setMediator($Mediator);
    }

    /**
     * Hook that is called after a compile process has completed.
     *
     * @throws \BLW\Model\InvalidArgumentException If <code>$Steps</code> is not numeric.
     *
     * @param int $Steps
     *            Steps completed.
     * @return bool <code>TRUE</code> on success. <code>False</code> otherwise.
     */
    public function doAdvance($Steps = 1)
    {
        // Is $Steps an integer?
        if (is_numeric($Steps)) {

            // Does command have a mediator?
            if ($this->_Mediator instanceof IMediator) {
                // Trigger hook
                $this->_do('Advance', new Event($this, array(
                    'Steps' => $Steps
                )));

                // Done
                return true;
            }
        }

        // Invalid $Callback
        else
            throw new InvalidArgumentException(0);

        // Error
        return false;
    }

    /**
     * Hook that is called after a compile process has completed.
     *
     * @throws \BLW\Model\InvalidArgumentException If <code>$Callback</code> is not callable.
     *
     * @param callable $Callback
     *            Callback to invoke.
     * @return bool <code>TRUE</code> on success. <code>False</code> otherwise.
     */
    public function onAdvance($Callback)
    {
        // Is $Callback callable?
        if (is_callable($Callback)) {

            // Does command have a mediator?
            if ($this->_Mediator instanceof IMediator) {
                // Register hook
                $this->_on('Advance', $Callback);

                // Done
                return true;
            }
        }

        // Invalid $Callback
        else
            throw new InvalidArgumentException(0);

        // Error
        return false;
    }

    /**
     * Optimizes a file and returns the optimized version of the file.
     *
     * @throws \BLW\Model\FileException If <code>$File</code> is not recognized as a file.
     *
     * @param string $File
     *            File to optimize
     * @return string Optimized version of the file.
     */
    public static function optimize($File)
    {
        if (! is_file($File) ?: ! is_readable($File)) {
            throw new FileException($File);
            return '';
        }

        switch (true) {
            case preg_match('!\x2ephp$!i', $File):
                return php_strip_whitespace($File);
            case preg_match('!\x2ecss$!i', $File):
                $Compressor = new CSSmin;
                return $Compressor->run(file_get_contents($File));
            case preg_match('!\x2ejs$!i', $File):
                return JSMin::minify(file_get_contents($File));
            default:
                return file_get_contents($File);
        }
    }

    /**
     * Adds a file for compilation.
     *
     * @throws \BLW\Model\FileException If there is an error with the file.
     *
     * @param \BLW\Type\IFile $File
     *            File to add to compiler.
     * @return bool <code>TRUE</code> on success. <code>FALSE</code> otherwise.
     */
    public function addFile(IFile $File)
    {
        // Is $File invalid?
        if (! $File->isFile() || ! $File->isReadable()) {

            // Exception
            throw new FileException($File);

            // Error
            return false;
        }

        // Add file
        $this->_Files[] = $File;

        // Success
        return true;
    }

    /**
     * Adds files in a directory for compilation.
     *
     * @throws \BLW\Model\FileException If <code>$Dir</code> is not a readable directory.
     *
     * @param \BLW\Type\IFile $Dir
     *            Directory to add files from.
     * @param string $Extention
     *            [optional] Extention of files to add.
     * @param ...
     * @return bool <code>TRUE</code> on success. <code>FALSE</code> otherwise.
     */
    public function addDir(IFile $Dir, $Extention = 'php')
    {
        static $Extract = NULL;

        // Extracts extentions from arguments and compiles them into a regex
        $Extract = $Extract ?: function ($r, $v)
        {
            static $i;

            if (empty($r)) $i = 1;

            // Is extention supported?
            if (preg_match('!^[\x2a\x2e0-9A-Z\x5fa-z]+$!', substr($v, 0, 16), $m)) {

                // Sanitize extention
                $m[0] = str_replace(array('.', '*'), array('\x2e', '.*'), $m[0]);

                // Add extention
                if (empty($r))
                    $r = "\\x2e$m[0]";

                else
                    $r .= "|\\x2e$m[0]";
            }

            // Invalid extention
            else
                throw new InvalidArgumentException($i, NULL, $i);

            // Update arg count
            $i ++;

            // Done
            return $r;

        };

        // Is $Dir invalid?
        if (! $Dir->isDir() || ! $Dir->isReadable()) {

            // Exception
            throw new FileException($Dir);

            // Error
            return false;
        }

        // Exclude regex
        $Excluded = '![\x2f\x5c](?:[^\x2f\x5c]*tests?|[^\x2f\x5c]*examples?|demos?|docs?)[\x2f\x5c]!i';

        // Include regex
        try {
            $Included = array_reduce(array_slice(func_get_args(), 1), $Extract, '');
            $Included = "!(?:$Included)$!i";
        }

        // Error
        catch(InvalidArgumentException $e) {

            // Forward exception
            throw new InvalidArgumentException($e->getCode(), null, 0, $e);

            // Error
            return false;
        }

        // Add files
        $added = 0;

        foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($Dir, FilesystemIterator::SKIP_DOTS | FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO), RecursiveIteratorIterator::SELF_FIRST) as $File) {

            // $File is a directory?
            if (is_dir($File))
                continue;

            // Is $File excluded?
            elseif (preg_match($Excluded, $File, $m))
                continue;

            // Is $File included
            elseif (preg_match($Included, $File)) {

                // Is file readable?
                if (is_readable($File) && is_file($File)) {
                    // Add file
                    $this->_Files[] = $File;

                    // Increase counter
                    $added++;
                }
            }
        }

        // Done
        return $added > 1;
    }

    /**
     * Creates a PHAR archives in the build path.
     *
     * <h4>Note</h4>
     *
     * <p>Raises an <b>E_USER_WARNING</b> if a file cannot be accessed / read.</p>
     *
     * <hr>
     *
     * @throws \BLW\Model\InvalidArgumentException If <code>$Project</code> contains: <code> " * / : < > ? \ | NL CR TAB </code>.
     * @throws \RuntimeException
     *
     * @param string $Project
     *            Name of the project.
     * @return bool <code>TRUE</code> on success. <code>FALSE</code> otherwise.
     */
    public function compile($Project = 'APP')
    {
        // Is $Project invalid
        $Project = trim(@substr($Project, 0, 64));
        $Regex   = '!^([^\x00-\x1f\x22\x2a\x2f\x3a\x3c\x3e\x3f\x5c\x7c]{1,32})(?:\x2e[Pp][Hh][Aa][Rr])?$!';

        if (! preg_match($Regex, $Project, $m)) {

            // Exception
            throw new InvalidArgumentException(0);

            // Error
            return false;
        }

        // Create PHAR
        $PHAR = sprintf('%s%s%s.phar', $this->_Build, DIRECTORY_SEPARATOR, $Project);
        $PHAR = new Phar($PHAR, FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::KEY_AS_FILENAME, "$Project.phar");

        $PHAR->setSignatureAlgorithm(Phar::SHA1);
        $PHAR->startBuffering();

        $this->doAdvance(10);

        // Add files to phar
        foreach ($this->_Files as $File) {

            // Is file readable?
            if (is_readable($File)) {

                // Generate path
                $Path = str_replace($this->_Root . '/', '', $File);
                $Path = str_replace($this->_Root . '\\', '', $File);
                $Path = str_replace(DIRECTORY_SEPARATOR, '/', $Path);

                // Optimize and add
                $PHAR->addFromString($Path, $this->optimize($File));

                // Advance Event
                $this->doAdvance();
            }

            // @codeCoverageIgnoreStart

            // $File is not readable
            else
                // Warning
                trigger_error(sprintf('Unable to read file (%s) with mode (%o)', $File, @fileperms($File)), E_USER_WARNING);

            // @codeCoverageIgnoreEnd
        }

        // Stub
        $ReadmePath = $this->_Root . DIRECTORY_SEPARATOR . 'app' . DIRECTORY_SEPARATOR . 'readme.php';

        // Does $ReadmePath exist?
        if (is_readable($ReadmePath)) {

            // Add Stub
            $PHAR['_stub.php'] = file_get_contents($ReadmePath);

            $PHAR->setStub($PHAR->createDefaultStub('_stub.php'));
        }

        // Done
        $PHAR->stopBuffering();

        unset($PHAR);

        // Advance Event
        $this->doAdvance(10);

        // Success
        return true;
    }
}

// @codeCoverageIgnoreStart
return true;
// @codeCoverageIgnoreEnd

